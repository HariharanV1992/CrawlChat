name: Deploy Complete CrawlChat Service

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deploy_infrastructure:
        description: 'Deploy/Update Infrastructure'
        required: false
        default: true
        type: boolean
      deploy_lambda:
        description: 'Deploy Lambda Functions'
        required: false
        default: true
        type: boolean
      deploy_ui:
        description: 'Deploy UI (if applicable)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: ap-south-1
  STACK_NAME: crawlchat-complete-stack
  LAMBDA_ECR_REPOSITORY: crawlchat-api-function
  CRAWLER_ECR_REPOSITORY: crawlchat-crawler-function
  LAMBDA_FUNCTION_NAME: crawlchat-api-function
  CRAWLER_FUNCTION_NAME: crawlchat-crawler-function
  S3_BUCKET: crawlchat-data
  DOMAIN_NAME: api.crawlchat.site

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Validate CloudFormation templates
      run: |
        echo "ğŸ” Validating CloudFormation templates..."
        aws cloudformation validate-template --template-body file://infra/crawlchat-complete-infrastructure.yml
        aws cloudformation validate-template --template-body file://infra/crawlchat-crawl-worker.yml
        echo "âœ… All templates are valid"

  build-and-push:
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ github.event.inputs.deploy_lambda != 'false' || github.event_name == 'push' }}
    outputs:
      lambda-image: ${{ steps.build-lambda.outputs.lambda-image }}
      crawler-image: ${{ steps.build-crawler.outputs.crawler-image }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Create ECR repositories
      run: |
        echo "ğŸ—ï¸ Creating ECR repositories..."
        for repo in ${{ env.LAMBDA_ECR_REPOSITORY }} ${{ env.CRAWLER_ECR_REPOSITORY }}; do
          aws ecr describe-repositories --repository-names $repo --region ${{ env.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository --repository-name $repo --region ${{ env.AWS_REGION }}
          echo "âœ… Repository $repo ready"
        done
    
    - name: Build and push Lambda API image
      id: build-lambda
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "ğŸ³ Building Lambda API image..."
        echo "ğŸ“‹ Build context: $(pwd)"
        echo "ğŸ“‹ Dockerfile path: lambda-service/Dockerfile"
        echo "ğŸ“‹ ECR Registry: $ECR_REGISTRY"
        echo "ğŸ“‹ Image Tag: $IMAGE_TAG"
        
        cd crawlchat-service
        echo "ğŸ“‹ Changed to directory: $(pwd)"
        echo "ğŸ“‹ Directory contents:"
        ls -la
        
        echo "ğŸ“‹ Lambda service contents:"
        ls -la lambda-service/
        
        echo "ğŸ“‹ Common package contents:"
        ls -la common/
        
        docker build --no-cache -f lambda-service/Dockerfile -t $ECR_REGISTRY/${{ env.LAMBDA_ECR_REPOSITORY }}:$IMAGE_TAG .
        
        if [ $? -eq 0 ]; then
          echo "âœ… Docker build successful"
        else
          echo "âŒ Docker build failed"
          exit 1
        fi
        
        docker tag $ECR_REGISTRY/${{ env.LAMBDA_ECR_REPOSITORY }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.LAMBDA_ECR_REPOSITORY }}:latest
        
        echo "ğŸ“¤ Pushing Lambda API image..."
        docker push $ECR_REGISTRY/${{ env.LAMBDA_ECR_REPOSITORY }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.LAMBDA_ECR_REPOSITORY }}:latest
        
        echo "lambda-image=$ECR_REGISTRY/${{ env.LAMBDA_ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "âœ… Lambda API image built and pushed"
        
        # Validate that the image was actually pushed
        echo "ğŸ” Validating image push..."
        if aws ecr describe-images --repository-name ${{ env.LAMBDA_ECR_REPOSITORY }} --image-ids imageTag=$IMAGE_TAG --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "âœ… Image validation successful"
        else
          echo "âŒ Image validation failed - image not found in ECR"
          exit 1
        fi
    
    - name: Build and push Crawler image
      id: build-crawler
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "ğŸ³ Building Crawler image..."
        echo "ğŸ“‹ Build context: $(pwd)"
        echo "ğŸ“‹ Dockerfile path: crawler-service/Dockerfile"
        echo "ğŸ“‹ ECR Registry: $ECR_REGISTRY"
        echo "ğŸ“‹ Image Tag: $IMAGE_TAG"
        
        cd crawlchat-service
        echo "ğŸ“‹ Changed to directory: $(pwd)"
        echo "ğŸ“‹ Crawler service contents:"
        ls -la crawler-service/
        
        docker build --no-cache -f crawler-service/Dockerfile -t $ECR_REGISTRY/${{ env.CRAWLER_ECR_REPOSITORY }}:$IMAGE_TAG .
        
        if [ $? -eq 0 ]; then
          echo "âœ… Docker build successful"
        else
          echo "âŒ Docker build failed"
          exit 1
        fi
        
        docker tag $ECR_REGISTRY/${{ env.CRAWLER_ECR_REPOSITORY }}:$IMAGE_TAG $ECR_REGISTRY/${{ env.CRAWLER_ECR_REPOSITORY }}:latest
        
        echo "ğŸ“¤ Pushing Crawler image..."
        docker push $ECR_REGISTRY/${{ env.CRAWLER_ECR_REPOSITORY }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.CRAWLER_ECR_REPOSITORY }}:latest
        
        echo "crawler-image=$ECR_REGISTRY/${{ env.CRAWLER_ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "âœ… Crawler image built and pushed"

  # Add debug job to print outputs
  debug-print-lambda-image:
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Print lambda-image output
        run: |
          echo "lambda-image output: ${{ needs.build-and-push.outputs.lambda-image }}"

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: ${{ github.event.inputs.deploy_infrastructure != 'false' || github.event_name == 'push' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Create S3 bucket for deployment
      run: |
        echo "ğŸª£ Creating S3 bucket for deployment..."
        aws s3api create-bucket \
          --bucket ${{ env.S3_BUCKET }} \
          --region ${{ env.AWS_REGION }} \
          --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }} \
          2>/dev/null || echo "Bucket already exists"
        
        # Enable versioning
        aws s3api put-bucket-versioning \
          --bucket ${{ env.S3_BUCKET }} \
          --versioning-configuration Status=Enabled
    
    - name: Check and fix CloudFormation stack state
      run: |
        echo "ğŸ” Checking CloudFormation stack state..."
        
        # Check if stack exists and get its status
        STACK_EXISTS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")
        
        echo "ğŸ“‹ Current stack status: $STACK_EXISTS"
        
        # Delete stack if it's in a failed state
        if [ "$STACK_EXISTS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_EXISTS" = "CREATE_FAILED" ] || [ "$STACK_EXISTS" = "UPDATE_FAILED" ] || [ "$STACK_EXISTS" = "ROLLBACK_IN_PROGRESS" ]; then
          echo "ğŸ—‘ï¸  Deleting failed stack in $STACK_EXISTS state..."
          
          # Force delete the stack
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo "â³ Waiting for stack deletion to complete..."
          
          # Wait for deletion with timeout
          TIMEOUT=600  # 10 minutes
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            
            if [ "$STACK_STATUS" = "STACK_NOT_FOUND" ]; then
              echo "âœ… Stack deleted successfully"
              break
            fi
            
            echo "â³ Still deleting... Status: $STACK_STATUS"
            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âš ï¸  Stack deletion timed out, but continuing with deployment"
          fi
        elif [ "$STACK_EXISTS" = "STACK_NOT_FOUND" ]; then
          echo "â„¹ï¸  Stack does not exist - will create new one"
        else
          echo "â„¹ï¸  Stack is in state: $STACK_EXISTS - proceeding with deployment"
        fi

    - name: Deploy complete infrastructure
      run: |
        echo "ğŸ—ï¸ Deploying complete infrastructure..."
        
        # Validate that we have a valid image URI
        LAMBDA_IMAGE_URI="${{ needs.build-and-push.outputs.lambda-image }}"
        echo "ğŸ“‹ Lambda Image URI: $LAMBDA_IMAGE_URI"
        
        if [ -z "$LAMBDA_IMAGE_URI" ]; then
          echo "âŒ Lambda Image URI is empty - cannot deploy"
          exit 1
        fi
        
        # Validate that the image exists in ECR
        echo "ğŸ” Validating image exists in ECR..."
        IMAGE_TAG=$(echo "$LAMBDA_IMAGE_URI" | sed 's/.*://')
        REPO_NAME=$(echo "$LAMBDA_IMAGE_URI" | sed 's/.*\///' | sed 's/:.*//')
        
        if ! aws ecr describe-images --repository-name $REPO_NAME --image-ids imageTag=$IMAGE_TAG --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "âŒ Image not found in ECR - cannot deploy"
          exit 1
        fi
        
        echo "âœ… Image validation successful"
        
        # Build parameter overrides
        PARAM_OVERRIDES="LambdaImageUri=$LAMBDA_IMAGE_URI DomainName=${{ env.DOMAIN_NAME }}"
        
        # Add certificate if available
        if [ -n "${{ secrets.CERTIFICATE_ARN }}" ]; then
          PARAM_OVERRIDES="$PARAM_OVERRIDES CertificateArn=${{ secrets.CERTIFICATE_ARN }}"
          echo "ğŸ“‹ Using certificate: ${{ secrets.CERTIFICATE_ARN }}"
        else
          echo "âš ï¸  No certificate provided - custom domain will not be configured"
        fi
        
        # Try to deploy with retry logic
        MAX_RETRIES=3
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "ğŸ”„ Deployment attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"
          
          if aws cloudformation deploy \
            --template-file infra/crawlchat-complete-infrastructure.yml \
            --stack-name ${{ env.STACK_NAME }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides $PARAM_OVERRIDES \
            --region ${{ env.AWS_REGION }}; then
            echo "âœ… Infrastructure deployed successfully"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "âŒ Deployment attempt $RETRY_COUNT failed"
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "â³ Waiting 30 seconds before retry..."
              sleep 30
              
              # Check if stack is in a failed state and delete it
              STACK_STATUS=$(aws cloudformation describe-stacks \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --query 'Stacks[0].StackStatus' \
                --output text 2>/dev/null || echo "STACK_NOT_FOUND")
              
              if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "UPDATE_FAILED" ]; then
                echo "ğŸ—‘ï¸  Deleting failed stack before retry..."
                aws cloudformation delete-stack \
                  --stack-name ${{ env.STACK_NAME }} \
                  --region ${{ env.AWS_REGION }}
                
                echo "â³ Waiting for stack deletion..."
                sleep 60
              fi
            fi
          fi
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "âŒ All deployment attempts failed"
          exit 1
        fi
    
    - name: Get deployment outputs
      id: outputs
      run: |
        echo "ğŸ“‹ Getting deployment outputs..."
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
          --output text)
        
        CUSTOM_URL=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`CustomDomainUrl`].OutputValue' \
          --output text)
        
        echo "api-url=$API_URL" >> $GITHUB_OUTPUT
        echo "custom-url=$CUSTOM_URL" >> $GITHUB_OUTPUT

  deploy-lambda-functions:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]
    if: ${{ github.event.inputs.deploy_lambda != 'false' || github.event_name == 'push' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update Lambda API function
      run: |
        echo "ğŸ”„ Updating Lambda API function..."
        aws lambda update-function-code \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --image-uri ${{ needs.build-and-push.outputs.lambda-image }} \
          --region ${{ env.AWS_REGION }}
        
        echo "â³ Waiting for Lambda update..."
        aws lambda wait function-updated \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --region ${{ env.AWS_REGION }}
        
        echo "âœ… Lambda API function updated"
    
    - name: Update Lambda environment variables
      if: false  # Skipping this step as per user request
      run: |
        echo "âš™ï¸ Updating Lambda environment variables..."
        VARS=$(jq -c -n '{
          ENVIRONMENT: "production",
          S3_BUCKET: "${{ env.S3_BUCKET }}",
          MONGODB_URI: "${{ secrets.MONGODB_URI }}",
          DB_NAME: "stock_market_crawler",
          COLLECTION_PREFIX: "crawler",
          SCRAPINGBEE_API_KEY: "${{ secrets.SCRAPINGBEE_API_KEY }}",
          OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}",
          OPENAI_MODEL: "gpt-4o-mini",
          OPENAI_MAX_TOKENS: "4000",
          OPENAI_TEMPERATURE: "0.1",
          SECRET_KEY: "${{ secrets.SECRET_KEY }}",
          ALGORITHM: "HS256",
          ACCESS_TOKEN_EXPIRE_MINUTES: "30",
          CORS_ORIGINS: "[\"https://crawlchat.site\",\"https://www.crawlchat.site\"]",
          CRAWLER_MAX_WORKERS: "10",
          CRAWLER_TIMEOUT: "30",
          CRAWLER_DELAY: "1.0",
          CRAWLER_MAX_PAGES: "100",
          CRAWLER_MAX_DOCUMENTS: "20",
          CRAWLER_USER_AGENT: "StockMarketCrawler/1.0",
          USE_PROXY: "true",
          PROXY_API_KEY: "${{ secrets.PROXY_API_KEY }}",
          S3_DOCUMENTS_PREFIX: "documents/",
          S3_CRAWLED_DATA_PREFIX: "crawled_data/",
          MAX_FILE_SIZE_MB: "50",
          PROCESSING_TIMEOUT: "300",
          BATCH_SIZE: "10",
          LOG_LEVEL: "INFO",
          LOG_FILE: "/var/log/crawlchat/app.log"
        }')
        aws lambda update-function-configuration \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --environment "Variables=$VARS" \
          --region ${{ env.AWS_REGION }}
        echo "âœ… Environment variables updated"
    
    - name: Update Crawler function (if exists)
      run: |
        echo "ğŸ”„ Updating Crawler function..."
        if aws lambda get-function --function-name ${{ env.CRAWLER_FUNCTION_NAME }} --region ${{ env.AWS_REGION }} 2>/dev/null; then
          aws lambda update-function-code \
            --function-name ${{ env.CRAWLER_FUNCTION_NAME }} \
            --image-uri ${{ needs.build-and-push.outputs.crawler-image }} \
            --region ${{ env.AWS_REGION }}
          
          aws lambda wait function-updated \
            --function-name ${{ env.CRAWLER_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Crawler function updated"
        else
          echo "âš ï¸ Crawler function not found - skipping"
        fi

  test-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-lambda-functions]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Wait for functions to be ready
      run: |
        echo "â³ Waiting for functions to be ready..."
        sleep 30
    
    - name: Test Lambda API function
      run: |
        echo "ğŸ§ª Testing Lambda API function..."
        cd crawlchat-service
        
        # Test with minimal API Gateway payload
        echo "ğŸ“‹ Testing with minimal API Gateway payload..."
        aws lambda invoke \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --payload '{"httpMethod":"GET","path":"/","headers":{},"queryStringParameters":null,"body":null,"isBase64Encoded":false}' \
          --region ${{ env.AWS_REGION }} \
          test_response.json
        
        echo "ğŸ“„ Test response:"
        cat test_response.json | jq .
        
        # Test crawler endpoint
        echo "ğŸ“‹ Testing crawler endpoint..."
        aws lambda invoke \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --payload '{"url":"https://example.com"}' \
          --region ${{ env.AWS_REGION }} \
          crawler_response.json
        
        echo "ğŸ“„ Crawler test response:"
        cat crawler_response.json | jq .
        
        # Test API Gateway health endpoint
        echo "ğŸ“‹ Testing API Gateway health endpoint..."
        aws lambda invoke \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --payload '{"httpMethod":"GET","path":"/health","headers":{},"queryStringParameters":null,"body":null,"isBase64Encoded":false}' \
          --region ${{ env.AWS_REGION }} \
          response.json
        
        echo "ğŸ“„ Health check response:"
        cat response.json | jq .
        
        echo "âœ… Function tests completed"

  notify:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-lambda-functions, test-deployment]
    if: always()
    steps:
    - name: Deployment Summary
      run: |
        echo "ğŸ‰ CrawlChat Service Deployment Summary"
        echo "======================================"
        echo ""
        echo "âœ… Infrastructure: ${{ needs.deploy-infrastructure.result }}"
        echo "âœ… Lambda Functions: ${{ needs.deploy-lambda-functions.result }}"
        echo "âœ… Tests: ${{ needs.test-deployment.result }}"
        echo ""
        echo "ğŸ”— API Gateway URL: ${{ needs.deploy-infrastructure.outputs.api-url }}"
        echo "ğŸ”— Custom Domain: ${{ needs.deploy-infrastructure.outputs.custom-url }}"
        echo "ğŸ”— Lambda Function: ${{ env.LAMBDA_FUNCTION_NAME }}"
        echo "ğŸ”— Crawler Function: ${{ env.CRAWLER_FUNCTION_NAME }}"
        echo ""
        echo "ğŸ“‹ Next Steps:"
        echo "   1. Test your API endpoints"
        echo "   2. Monitor CloudWatch logs"
        echo "   3. Check S3 cache functionality"
        echo "   4. Verify ScrapingBee integration"
        echo "   5. Test cost optimization features"
        
        if [ "${{ needs.test-deployment.result }}" != "success" ]; then
          echo "âš ï¸ Some tests failed - check CloudWatch logs for details"
          exit 1
        fi 